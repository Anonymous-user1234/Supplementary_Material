
    bool rebuild_basis(Bvvec_t & candidates) { 

		bool display = 0;

		basis.clear();
		basis_map.clear();
		ops.clear();

		wind_t level = 0;

		while (true) {
			Bvvec_t added;

			for (auto & test_b : candidates) {
				assert(test_b.vector.count() > 0);
				if(test_b.imp_depth == 0){
					added.emplace_back(test_b);
					continue;
				}

                if(test_b.vector.count()==1){
                    for(int gpos = DIMENSION; gpos < DIMENSION + NL_NUM; gpos++){

                        if(test_b.vector.test(gpos)){
                            vec_t t0 = gys[gpos - DIMENSION].t_vec[0];
                            vec_t t1 = gys[gpos - DIMENSION].t_vec[1];
                            int app = 0;
                            int depth = -1;
                            int src_0 = -1, src_1 = -1;
                            for (auto const & it: basis_map){
                                if(it.first.vector == t0 || it.first.vector == t1){
                                    if(src_0 < 0){
                                        src_0 = it.second;
                                    }else{
                                        if(src_0 > it.second){
                                            src_1 = src_0;
                                            src_0 = it.second;
                                        }else{
                                            src_1 = it.second;
                                        }
                                    }
                                    app ++;

                                    if(it.first.imp_depth > depth){
                                        depth = it.first.imp_depth;
                                    }
                                }
                            }
                            if(app == 2 ){

                                test_b.imp_depth = depth + 1;
								if(test_b.imp_depth > DEPTH_LIMIT){
									return false;
								}
								assert(test_b.imp_depth <= DEPTH_LIMIT);

                                ops.emplace_back(op_t({wind_t(ops.size())  + DIMENSION, src_0, src_1, gys[gpos - DIMENSION].type, get_target_index(test_b.vector)}));
                                added.emplace_back(test_b);
                            }
                        }
                    }
                }

                bool find_xor = false;
				for (wind_t bi = 0; bi < basis.size(); ++bi) {
                    vec_t bnew = test_b.vector ^ basis[bi].vector;
                    for(auto & it : basis_map){
                        if(it.first.vector == bnew && bi < it.second){
                            test_b.imp_depth = std::max(basis[bi].imp_depth, it.first.imp_depth)+1;
                            if(test_b.imp_depth > DEPTH_LIMIT){
								return false;
							}
							assert(test_b.imp_depth <= DEPTH_LIMIT);
							added.emplace_back(test_b);
                            auto src_0 = bi;
                            auto src_1 = it.second;
                            assert(src_0 < src_1);
                            ops.emplace_back(op_t({wind_t(ops.size())  + DIMENSION, src_0, src_1, TYPE_XOR, get_target_index(test_b.vector)}));
                            find_xor = true;
                            break;
                        }
                    }
                    if(find_xor){
                        break;
                    }
				}
                
			}

			if (display)
				std::cout << "level " << level++ << ": " << added.size()
			    	      << ", \t current basis: " << basis.size()
			        	  << ", \t todo: " << candidates.size() 
			          	  << std::endl;


			if (added.size() == 0)
				break;

			for (auto const & b : added) {
				basis_map[b] = basis.size();
				basis.emplace_back(b);
                candidates.erase(std::remove(candidates.begin(), candidates.end(), b), candidates.end());
			}
		}

		if (display)
			std::cout << "\t final level " << level 
					  << ", \t basis: " << basis.size() 
					  << ", \t remain: " << candidates.size() 
					  << std::endl << std::endl;

        // convert xor to nxor
		for (wind_t oi = 0; oi < ops.size(); ++oi) {
			auto & op = ops[oi];
			if (op.tar_idx < 0) continue;

			auto ti = op.tar_idx;
			op.tar_idx = get_y_index(basis[op.dst].vector);
			if (op.tar_idx < 0) continue;

			if (!targets[ti].has_one) continue;


			if (op.type != TYPE_XOR && op.type != TYPE_NXOR) {
				std::cout << "y[" << op.tar_idx << "] cannot be generated by xor/nxor" << std::endl;
				return false;
			}

			if (op.type == TYPE_XOR) op.type = TYPE_NXOR;
			else if (op.type == TYPE_NXOR) op.type = TYPE_XOR;

			for (wind_t oj = oi + 1; oj < ops.size(); ++oj) {
				if (ops[oj].src_0 == op.dst || ops[oj].src_1 == op.dst) {
					if (ops[oj].type != TYPE_XOR && ops[oj].type != TYPE_NXOR) {
						std::cout << "y[" << op.tar_idx << "] cannot be used latter" << std::endl;
						return false;
					}
					if (ops[oj].type == TYPE_XOR) ops[oj].type = TYPE_NXOR;
					else if (ops[oj].type == TYPE_NXOR) ops[oj].type = TYPE_XOR;
				}
			}


		}

        if (candidates.size() == 0)
			ops_check();

		return candidates.size() == 0;
	}



// input: basis or ops
// output: simplified basis, basis map, del_vec_infos, ops;
// return true if succeed
bool delete_vector_infos() { 

    PRINTF_STAMP("compute outs for each vector to be deleted\n");

    Timer tt;
    tt.start();

    assert(basis.size() > DIMENSION || ops.size());

    assert(basis.size() > DIMENSION);
    Bvvec_t basis_set;
    
    for (auto const & b : basis) {
        basis_set.emplace_back(b);
    }

    basis.clear();
    basis_map.clear();
    ops.clear();


    // 1. check redundants
    bool reduced = false;
    Bvvec_t redundants;
    do {
        if (redundants.size() > 0) {
            reduced = true;
            for (auto const & rb : redundants){
                rb.print();
                basis_set.erase(std::remove(basis_set.begin(), basis_set.end(), rb), basis_set.end());
            }
            std::cout << "found " << redundants.size() << " redundant vectors" << std::endl;
            redundants.clear();			
        }

        del_vec_infos.clear();
        for (auto const & b : basis_set) {
            if (b.vector.count() == 1 || get_target_index(b.vector) >= 0 || get_y_index(b.vector) >= 0) {
                continue;
            }
            auto & rec_info = del_vec_infos[b];				

            rec_info.affected = basis_set;
            rec_info.affected.erase(std::remove(rec_info.affected.begin(), rec_info.affected.end(), b), rec_info.affected.end());

            rec_info.useful_set.clear();
            extend_vectors(rec_info.useful_set, rec_info.affected, gys);

            if (rec_info.affected.size() == 0) {
                redundants.emplace_back(b);
                break;
            }
        }
    } while (redundants.size() > 0);


    // 2. update key_len
    for (auto const & b : basis_set) {
        if (b.vector.count() == 1 ||  get_target_index(b.vector) >= 0 || get_y_index(b.vector) >= 0){
            
            continue;
        }
        auto & rec_info = del_vec_infos[b];
        if(!calc_key_len(rec_info.useful_set, rec_info.affected, gys)){
            del_vec_infos.erase(b);
        }else{
            del_vec_infos[b].key_len = 1;
        }
    }

    // 3. rebuild basis, basis_map, ops
    if (!rebuild_basis(basis_set)) {
        std::cout << "delete_vector_infos error !!!!" << std::endl;
        return false;
    }

    if (reduced) {
        ops_check();
    }

    return true;
}


wind_t smallest_lincomb_by_enum(std::vector<idx_t> & lins, 
                                Bvvec_t const & basis_in_use, 
                                Bvector const & target, 
                                wind_t const len_bound) {

    assert(lins.size() == 0);
    
    std::map<Bvector, wind_t> bumap;
    
    for (wind_t i = 0; i < basis_in_use.size(); ++i) {
        bumap[basis_in_use[i]] = i;
    }

    auto target_it = bumap.find(target);
    if (target_it != bumap.end()) {
        idx_t lin = {target_it->second};
        lins.emplace_back(lin);
        return 1;
    }

    for (wind_t len = 2; len <= len_bound; ++len) {
        Enumerator enumer(len - 1, basis_in_use.size());

        while (enumer.step()) {
            auto sel_idxs = enumer.current();
            
            Bvector vec = target;
            
            for (auto const & idx : sel_idxs) {
                vec.linear_op(vec, basis_in_use[idx]); 
            }
            
            auto it = bumap.find(vec);
            if (it != bumap.end() && it->second > *sel_idxs.rbegin()) {
                auto lin = sel_idxs;
                lin.emplace_back(it->second);
                lins.emplace_back(lin);
            }
        }

        if (lins.size() > 0) {
            return len;
        }
    }

    return -1;
}


wind_t smallest_lincomb_by_gurobi(std::vector<idx_t> & lins, Bvvec_t const & basis_in_use, Bvector const & target) { //ok4.7

		assert(target.vector.count() > 0);
		// Create an environment
		GRBEnv env = GRBEnv(true);
		env.set(GRB_IntParam_OutputFlag, 0);
		env.start();
		// Create an empty model
		GRBModel model = GRBModel(env);


		std::vector<GRBVar> sel;
		GRBLinExpr n_sel = 0;
		for (auto const b : basis_in_use) {
			auto v = model.addVar(0., 1., 0., GRB_BINARY);
			n_sel += v;
			sel.emplace_back(v);
		}
		model.addConstr(n_sel >= 1);

		int value_bound = dvalue(target.imp_depth);
		GRBLinExpr sum_depth = 0;
		for (wind_t i = 0; i < basis_in_use.size(); ++i)
			sum_depth += sel[i] * dvalue(basis_in_use[i].imp_depth);
		model.addConstr(sum_depth <= value_bound);


		// linear combination
		for (wind_t j = 0; j < DIMENSION + NL_NUM; ++j) {

			// deal with target[j] bit
			GRBLinExpr l = 0;
			for (wind_t i = 0; i < basis_in_use.size(); ++i)
				if (basis_in_use[i].vector.test(j))
					l += sel[i];

			if (target.vector.test(j)){
				 l += 1;
			}
			GRBVar m = model.addVar(0., DIMENSION + NL_NUM, 0., GRB_INTEGER);
			model.addConstr(l == 2 * m);
		}


		// paramters of gurobi

		model.set(GRB_IntParam_RINS, 0);
		model.set(GRB_IntParam_VarBranch, 2);
		model.set(GRB_IntParam_MIPFocus, 3);

		model.set(GRB_IntParam_Threads, 32);

		model.set(GRB_IntParam_PoolSearchMode, 2);
		model.set(GRB_IntParam_PoolSolutions, 1024);


		model.setObjective(n_sel, GRB_MINIMIZE);

		model.optimize();



		int solCount = model.get(GRB_IntAttr_SolCount);

		assert(solCount > 0);


		wind_t new_lincomb_num = DIMENSION + NL_NUM;
		for (int si = 0; si < solCount; ++si) {
		    model.set(GRB_IntParam_SolutionNumber, si);

		    idx_t lin;
		    for (int i = 0; i < sel.size(); ++i){
		        if (sel[i].get(GRB_DoubleAttr_Xn) > 0.5){
		        	lin.emplace_back(i);
                }
            }

		    if (new_lincomb_num > lin.size()) {
		    	new_lincomb_num = lin.size();
		    	lins.clear();
		    }

		    if (new_lincomb_num == lin.size() && lin.size() > 1)
		    	lins.emplace_back(lin);
		}
		assert(new_lincomb_num > 0);

		return new_lincomb_num;
	}



	inline wind_t smallest_lincomb_packed(std::vector<idx_t> & lins, 
										Bvvec_t const & basis_in_use, 
										Bvector const & target,
										wind_t const upper_bound) { 


        wind_t min_len =smallest_lincomb_by_gurobi(lins, basis_in_use, target);
        assert(min_len > 0);
		return min_len;
	}




void merge_get_lincombs(std::vector<Sub_target> & subtar_nodes) { 

		bool display = 0;


		PRINTF_STAMP("Merge and generate linear combinations from %ld outs 1\n", del_vec_infos.size());
		Timer tall;
		tall.start();

        std::map<Bvector, bool> used;
		for (auto const & it : del_vec_infos)
			used[it.first] = (it.second.key_len != 1);

		Bvvec_t basis_set;
		for (auto const & b : basis) basis_set.emplace_back(b);

		std::string to_print;
		for (auto const & it : del_vec_infos) {
			if (used.at(it.first) == true) continue;
			used[it.first] = true;

		    Bvvec_t to_delete = {it.first};

		    bool canmerge = true;
			while (canmerge) {
				canmerge = false;

				for (auto const & itt : del_vec_infos) { 
					if (used.at(itt.first) == true) continue;

					// check whether can merge
					Delete_vector newnode;

					newnode.affected = basis_set;
					for (auto const & b : to_delete)
						VEC_ERASE(newnode.affected, b)

                    VEC_ERASE(newnode.affected, itt.first) 

					newnode.useful_set.clear(); 
					extend_vectors(newnode.useful_set, newnode.affected, gys); 
					if (calc_key_len(newnode.useful_set, newnode.affected, gys)) {
						if (display)
							std::cout << "merged !!!!!!!!!!" << std::endl;
							to_delete.emplace_back(itt.first);

						
						used[itt.first] = true;
						canmerge = true;
						break;
					}
				}	
			}

			

			// genenrate linear combination
			Timer tt;
			tt.start();

			Sub_target subtar;
			for(auto & del_it :to_delete){
				if(std::find(basis.begin(), basis.end(), del_it) != basis.end()){
					subtar.to_delete.emplace_back(del_it);
				}else{
					for(auto const & bit: basis){
						if(bit.vector == del_it.vector){
							subtar.to_delete.emplace_back(bit);
							break;
						}
					}
				}
			}

			auto keys = subtar.possible_keys(basis_set, gys);
			if(keys.size() <= 0) { printf("keys.size() <= 0\n"); continue;}
            assert(keys.size() > 0);
	
			if (display) 
				std::cout << "start with keys " << keys.size() << std::endl;

			for (auto const & test_vec : keys) {
				// generate minimal linear combinations
				std::vector<idx_t> lins;

				
				subtar.min_len = smallest_lincomb_packed(lins, subtar.useful_set, test_vec, to_delete.size() + 2);

				if (subtar.min_len == -1 || subtar.min_len > to_delete.size() + 2)
					continue;


				subtar.target = test_vec;
				
				// convert to absolute index
				subtar.minimal_lincombs.clear();
				
				if(subtar.min_len == 1){
					printf("\nin gurobi target vector:\n");
					test_vec.print();
					printf("\nin gurobi lins vector:\n");
					for (auto const & lin : lins) {
						LinComb nlc(lin, subtar.useful_set);
						nlc.print();
						for(auto const &l : lin){

							subtar.useful_set[l].print();
							printf("\n");
						}
						printf("\n");
						
					}
				}
	   			
				for (auto const & lin : lins) {
                    LinComb nlc(lin, subtar.useful_set);

                    assert(nlc.value <= dvalue(subtar.target.imp_depth));

                    subtar.minimal_lincombs.emplace_back(nlc);
					
                }

				subtar.supports.clear();
				subtar.append_supports( subtar.minimal_lincombs, subtar.useful_set, basis);

				if (subtar.min_len < subtar.to_delete.size() + 2) {
					std::cout << "found unexpected linear combinations ~~~~~~" << std::endl;
				}
				
				subtar_nodes.emplace_back(subtar);
		    }
		}

		PRINTF_STAMP("All linear combinations are generated, time %.3f sec.\n\n", tall.used_time());

	}

    inline void sort_lincombs_by_depth(Bvvec_t & lincomb_vecs) {
		std::sort(lincomb_vecs.begin(), lincomb_vecs.end(), 
			[](const Bvector& a, const Bvector& b) {
				if (a.imp_depth != b.imp_depth) {
					return a.imp_depth < b.imp_depth;
				}
				
				for (int i = 0; i < DIMENSION + NL_NUM; i++) {
					if (a.vector[i] != b.vector[i]) {
						return a.vector[i] < b.vector[i];
					}
				}
				
				return a.ad_depth < b.ad_depth;
			}
		);
	}
    // add the vectors to basis set from the linear combination.
	void fill_gap(Bvvec_t & basis_set, Bvvec_t & lincomb_vecs) { 

		bool display = 0;

	 	if (display) PRINTF_STAMP("fill gap start: basis_set %ld, lincomb_vecs %ld\n", basis_set.size(), lincomb_vecs.size());

		// display
		if (display) {
			std::cout << "connecting:";
			for (auto const & v : lincomb_vecs) {				
				std::cout << " ";
				if (basis_map.find(v) != basis_map.end())
					std::cout << basis_map[v];
				else
					std::cout << -1;
			}
			printf("\n");
			for (auto const & v : lincomb_vecs) {	
                v.print();
                printf("\n");
            }

			std::cout << std::endl;
		}
		

		// step 1: last case
		if (lincomb_vecs.size() == 2) {

			auto const & s0 = *lincomb_vecs.begin();
			auto const & s1 = *lincomb_vecs.rbegin();
            
            Bvector bnew;
            bnew.linear_op(s0, s1);

			lincomb_vecs.clear();

			if (display) PRINTF_STAMP("fill gap done: basis_set %ld, lincomb_vecs %ld\n", basis_set.size(), lincomb_vecs.size());

			return;
		}

		// step 3: random select
		assert(lincomb_vecs.size() >= 2);
		auto it = lincomb_vecs.begin();
		auto s0 = *it;
		++it;
		auto s1 = *it;
        Bvector newb;
        newb.linear_op(s0, s1);
		
		if(std::find(basis_set.begin(), basis_set.end(), newb) == basis_set.end()){
			basis_set.emplace_back(newb);
		}

        VEC_ERASE(lincomb_vecs, s0)
        VEC_ERASE(lincomb_vecs, s1)
		lincomb_vecs.emplace_back(newb);
		sort_lincombs_by_depth(lincomb_vecs);
		fill_gap(basis_set, lincomb_vecs);


	}

    inline bool find_pair(idx_t const & lin, 
						  pair_t const & pa, 
						  std::vector<wind_t> & tail_idxs) { 
		wind_t cc = 0;
		tail_idxs.clear();
		for (auto const & idx : lin) {
			if (idx == pa.first || idx == pa.second) ++cc;
			else tail_idxs.emplace_back(idx);
		}
		if (cc < 2) tail_idxs.clear();
		return (cc == 2);
	}


    void print_lincomb_selpair(Sub_target const & subtar, 
					           pair_t const & pa) { 

		std::string equ;

		std::vector<wind_t> tail_idxs;

		for (auto const & lin: subtar.minimal_lincombs) {			

			if (!find_pair(lin.lin, pa, tail_idxs)) continue;

			equ += pad_to_len(basis_map[subtar.target], 3) + " = ";
			for (wind_t ii = 0; ii < lin.lin.size(); ++ii) {
				auto const & idx = lin.lin[ii];
				if (ii > 0) equ += " + ";
				equ += pad_to_len(idx, 3);
				equ += "[" + get_outs(basis[idx]) + "]";
			}
			equ += "\n";
		}
		equ += "\n";

		std::cout << equ;
	}

void find_reuse_pairs(std::map<pair_t, std::vector<del_tail_idxs_t>> & pair_to_idxs,
						  std::vector<Sub_target> const & subtar_nodes) { 

		bool display = 0;

		PRINTF_STAMP("Find pairs that can be reused from %ld linear nodes\n", subtar_nodes.size());
		Timer tall;
		tall.start();


		std::map<pair_t, wind_t> votes;
		for (auto const & subtar : subtar_nodes)
			for (auto const & pa : subtar.supports)
				votes[pa] += 1;

		std::vector<pair_t> pair_sort;
		for (auto const & it : votes)
			if (it.second > 1)
				pair_sort.emplace_back(it.first);

		std::sort(pair_sort.begin(), pair_sort.end(), [&votes](const pair_t & a, const pair_t & b) {
			return votes[a] > votes[b];
		});

		// display
		{
			wind_t ctr = 0;
			for (auto const & pa : pair_sort) {			
				if (votes[pa] == 1) continue;
				std::cout << "\t" << pad_to_len(ctr++, 3) << ": ";
				pair_print(pa, false);
				std::cout << ", vote: " << votes[pa] << std::endl;
			}
			std::cout << std::endl << std::endl;	
		}
		

		

		wind_t ctr = 0;
		for (auto const & pa : pair_sort) {
			assert(votes[pa] > 1);

			// display
			if (display) {
				std::cout << pad_to_len(ctr, 3) << ": ";
				pair_print(pa, false);
				std::cout << ", vote: " << votes[pa] << std::endl;	
			}
			++ctr;


			auto & rec_datas = pair_to_idxs[pa];
			for (auto const & subtar : subtar_nodes) {
				if (subtar.supports.find(pa) == subtar.supports.end()) continue;

				del_tail_idxs_t data;
				data.current_idx = basis_map[subtar.target];

				for (auto const & v : subtar.to_delete)
					data.del_idxs.emplace_back(basis_map[v]);

				for (auto const & lin: subtar.minimal_lincombs){
					idx_t lin_in_basis;
					for(auto const & l: lin.lin){
						auto it = std::find(basis.begin(), basis.end(), subtar.useful_set[l]);
					
						if (it != basis.end()) {
							lin_in_basis.emplace_back(std::distance(basis.begin(), it));
						}
					}
					assert(lin_in_basis.size() == lin.lin.size());

					if (find_pair(lin_in_basis, pa, data.tail_idxs))
						break;
				}
				// display
				if (display) {
					std::cout << "to delete:";
					for (auto & idx : data.del_idxs) std::cout << " " << idx;

					std::cout << ", tail:";
					for (auto & idx : data.tail_idxs) std::cout << " " << idx;
					std::cout << std::endl;

					print_lincomb_selpair(subtar, pa);
				}

				rec_datas.emplace_back(data);
			}

			if (display)
				std::cout << "================================================\n";		
		}


		if (ctr == 0)
			PRINTF_STAMP("no pairs are found !!!! time %.3f sec.\n\n", tall.used_time());
		else
			PRINTF_STAMP("%ld pairs are found, time %.3f sec.\n\n", pair_to_idxs.size(), tall.used_time());
	}


	

inline vecset_t get_deletes(del_tail_idxs_t const & first, del_tail_idxs_t const & second) { 

		std::set<wind_t> dels;
		for (auto const & del_idx : first.del_idxs) dels.emplace(del_idx);
		for (auto const & del_idx : second.del_idxs) dels.emplace(del_idx);

		dels.erase(first.current_idx);
		for (auto const & idx : first.tail_idxs)
			dels.erase(idx);

		dels.erase(second.current_idx);
		for (auto const & idx : second.tail_idxs)
			dels.erase(idx);

		vecset_t to_delete;
		for (auto const & idx : dels)
			to_delete.emplace(basis[idx]);

		return to_delete;
	}

    inline wind_t get_toadd_num(del_tail_idxs_t const & first, del_tail_idxs_t const & second) {

		return first.tail_idxs.size() - 1 + second.tail_idxs.size() - 1 + 1;
	}

	inline bool be_circle(del_tail_idxs_t const & first, del_tail_idxs_t const & second) { 

		bool b0 = false;
		for (auto const & idx : first.tail_idxs) 
			if (second.current_idx == idx)
				b0 = true;

		bool b1 = false;
		for (auto const & idx : second.tail_idxs) 
			if (first.current_idx == idx)
				b1 = true;
		return b0 && b1;
	}



bool my_local_reconstruct(){
    bool display = 1;
    Timer tall;
    tall.start();
    if (display) {
        PRINTF_STAMP("step 1: simplify the basis directly, and build up delete vector information, with %ld ops\n", ops.size());
    }	
    printf("basis size:%ld\n", basis.size());
    if (!delete_vector_infos())
		return false;
	assert(basis.size() > DIMENSION);

    if(display){
        std::cout<< "basis size:" << basis.size() << std::endl;
    }

    if (display) {
        PRINTF_STAMP("step 2: merge the subtargets from %ld outs 1\n", del_vec_infos.size());
    }

    std::vector<Sub_target> subtar_nodes;
    merge_get_lincombs(subtar_nodes);
	
    // step 3: deal with unexpected linear combinations
    if (display) {
        PRINTF_STAMP("step 3: deal with unexpected linear combinations\n");
    }


    Matrix best_mat = *this;
    bool shorten = false;
    for (auto  & subtar : subtar_nodes) {
        if (subtar.min_len < subtar.to_delete.size() + 2) {
            shorten = true;
            
            std::cout << "found new shorter linear combination of current basis_set" << std::endl;
            printf("minlen:%d. subtar.to_delete.size():%ld\n",subtar.min_len, subtar.to_delete.size());

			Bvvec_t basis_set;

            for (auto const & b : basis) basis_set.emplace_back(b);

			std::vector<Bvector> to_delete_final;
			for (auto const & d : subtar.to_delete) {
				if (std::find(basis_set.begin(), basis_set.end(), d) != basis_set.end()) {
					to_delete_final.push_back(d);
				}
			}

			subtar.to_delete = to_delete_final;


			for (auto const & d : subtar.to_delete) {
				auto it = std::find(basis_set.begin(), basis_set.end(), d);
				if (it != basis_set.end()) {
					basis_set.erase(it);

				} else {

					std::cout << "ERROR: Element not found in basis_set during deletion:" << std::endl;
					d.print(true);
				}
			}


            Bvvec_t lincomb_vecs;
            assert(subtar.minimal_lincombs.size() > 0);
            for (auto const & idx : subtar.minimal_lincombs[0].lin)
                lincomb_vecs.emplace_back(subtar.useful_set[idx]);
			if(lincomb_vecs.size() < 2){
				continue; 
			}
            fill_gap(basis_set, lincomb_vecs);
            assert(lincomb_vecs.size() == 0);

            Matrix mat = *this;

            if (mat.rebuild_basis(basis_set)) {

                mat.ops_check();
                printf("step 3 reduced!\n");
				

                mat.my_local_reconstruct();

                if (best_mat.ops.size() > mat.ops.size()){
                    best_mat = mat;
					mat.ops_print();
					mat.ops_write();
				}
            }
        }
    }
    if (shorten) {
        *this = best_mat;
        return true;
    }

    if(display){
        std::cout<< "basis size:" << basis.size() << std::endl;
    }

    if (display) {
        PRINTF_STAMP("step 4: generate possible pairs from %ld nodes\n", subtar_nodes.size());
    }

    std::map<pair_t, std::vector<del_tail_idxs_t>> pair_to_idxs;
    find_reuse_pairs(pair_to_idxs, subtar_nodes);

    if (display) {
			PRINTF_STAMP("step 5: check possible reductions from %ld pairs, and reconstruct\n", pair_to_idxs.size());
		}


    bool local_display = 1;
    wind_t ctr = 0;
    for (auto const & it : pair_to_idxs) {
            auto const & pa = it.first;
			auto const & rec_datas = it.second;

			// display
			if (local_display) {
				std::cout << "checking " << pad_to_len(ctr, 3) << ": ";
				pair_print(pa, false);
				std::cout << ", vote: " << rec_datas.size() << std::endl;
			}
			++ctr;

            for (wind_t i0 = 0; i0 < rec_datas.size(); ++i0) {
				auto const & first_data = rec_datas[i0];

				for (wind_t i1 = i0 + 1; i1 < rec_datas.size(); ++i1) {
					auto const & second_data = rec_datas[i1];
                    // display
					if (local_display) {
						std::cout << "checking..." << std::endl;

					}

					if (first_data.current_idx == second_data.current_idx) {
						if (local_display) std::cout << "the same target, pass 0\n\n";
						continue;
					}

					if (first_data.del_idxs == second_data.del_idxs) {
						if (local_display) std::cout << "deleting the same vectors, pass 00\n\n";
						continue;
					}

                    auto to_delete = get_deletes(first_data, second_data);
					auto n_adds = get_toadd_num(first_data, second_data);

					if (local_display) {
					   std::cout << "to delete: " << to_delete.size();
					   std::cout << " v.s. to add: " << n_adds << std::endl; 
					}


                    if (be_circle(first_data, second_data)) {
					   if (local_display) std::cout << "be circle, pass 1\n\n";
					   continue;
					}
					
					if (n_adds >= to_delete.size()) {
					   if (local_display) std::cout << "adds more vectors (" << n_adds << ") than the deleted (" << to_delete.size() << "), pass 2\n\n";
					   continue;
					}

                    // step 5: delete and resconsruct
					if (display)
						PRINTF_STAMP("step 5.*: delete and reconstruct %d/%ld\n", ctr - 1, pair_to_idxs.size());

					Bvvec_t basis_set;
					for (auto const & b : basis) basis_set.emplace_back(b);
					for (auto const & d : to_delete){
                        VEC_ERASE(basis_set, d)
                    }

					// add pair
					auto const & s0 = basis[pa.first];
					auto const & s1 = basis[pa.second];
					Bvector pair_b;
                    pair_b.linear_op(s0, s1);
                    assert(std::find(basis_set.begin(), basis_set.end(), pair_b) == basis_set.end());

					basis_set.emplace_back(pair_b);

					std::vector<del_tail_idxs_t> loc_rec_datas = {first_data, second_data};

					// deal with tails
					for (auto const & data : loc_rec_datas) {

					   	Bvvec_t lincomb_vecs = {pair_b};
					   	for (auto const & idx : data.tail_idxs)
					    	lincomb_vecs.emplace_back(basis[idx]);
						if(lincomb_vecs.size() < 2){
							return true; 
						}
					   	fill_gap(basis_set, lincomb_vecs);
					   	assert(lincomb_vecs.size() == 0);

					}

                    Matrix mat = *this;

					if (mat.rebuild_basis(basis_set)) {
						printf("step 5 reduced\n");
						mat.ops_check();


						std::cout << "good ~~~~~~" << std::endl;

						mat.my_local_reconstruct();


						if (best_mat.ops.size() > mat.ops.size()){
							best_mat = mat;
							mat.ops_print();
							mat.ops_write();
						}
							

					} else {
						std::cout << "cannot rebuild basis!!! pass 4\n\n";
					}

					
                }
            }


    }

    if(display){
        std::cout<< "basis size:" << basis.size() << std::endl;
    }

    if (ops.size() > best_mat.ops.size())
			*this = best_mat;
			
	PRINTF_STAMP("local reconstruction is done, time %.3f sec.\n", tall.used_time());

	return true;
}